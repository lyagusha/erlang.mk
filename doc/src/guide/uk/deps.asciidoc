[[ua_deps]]
== Пакунки та залежності

Erlang.mk має можливість отримання і компіляції залежностей потрібних 
вашому проекту. Покращені концепції, що були введені у Rebar, мають 
бути знайомі досвідченим розробникам.

Erlang.mk не є менеджером пакунків, проте він містить в собі індекс
пакунків Erlang для полегшення пошуку корисних проектів.

У цьому розділі йдеться про використання пакунків, додавання залежностей
для вашого проекту або поєднання їх безпосередньо в одному репозиторії.

=== Пошук пакунків

Erlang.mk надає доступ до майже 500 пакунків, їх кількість регулярно 
збільшується.

Для пошуку пакунків виконайте наступне:

[source,bash]
$ make search q=pool

Вам будуть запропоновані пакунки, що в назві чи описі містять "pool"

Ви також можете переглянути весь список і використовувати стандартні 
інструменти командного рядка для пошуку потрібного пакунку, наприклад:

[source,bash]
$ make search | less

=== Додавання залежностей до вашого проекту

Після того як ви знайшли потрібний пакунок, додайте його в якості
залежності до вашого проекту:

[source,make]
DEPS = cowboy

От і все! Наступного разу, при виконанні make, Erlang.mk отримає та 
зробить компіляцію Сowboy. Erlang.mk також зробе Cowboy доступним 
під час роботи вашого додатку, виконання тестів тощо... 

Erlang.mk доповнить файл ресурсів програми усіма додатками,  
знайденими у DEPS. Проте не всі залежності є Erlang додатками та 
не всі залежності є залежностями часу-виконання. В такому випадку 
стане у нагоді атрибут BUILD_DEPS. Він працює так само, як DEPS, 
за винятком того що, залежностей, перерахованих там не буде додано 
в якості залежностей під час виконання додатку.

Наприклад, ви маєте можливість використання parse transform додатку 
лише під час збирання проекту:

[source,make]
BUILD_DEPS = erlando

Або може знадобитися залежність від проекту на С під час написання NIF:

[source,make]
BUILD_DEPS = leveldb
dep_leveldb = git https://github.com/basho/leveldb 2.1.3

Ця залежність буде побудована до вашого додатку, тому ви можете 
скопіювати отриманний файл до теки "priv/" як частину процесу збирання.
Докладніше дивись у розділі "NIFs and port drivers chapter".

Інший атрибут, `LOCAL_DEPS`, дозволяє додавати у залежності 
часу-виконання додатки що є частиною Erlang/OTP або знаходяться у 
репозиторії. Оскільки вони вже є у вашій системі, немає необхідності
в їх отриманні. Зверніть увагу, немає способу обрати версію додатка,
буде використовуватись та версія що встановлена в вашій системі.

Наприклад, ваш проект може залежати від додатку Crypto:

[source,make]
LOCAL_DEPS = crypto

Також Erlang.mk містить декілько додаткових типів залежностей. 
`TEST_DEPS` для залежностей, що використовуються лише під час тестування:

[source,make]
TEST_DEPS = ct_helper
dep_ct_helper = git https://github.com/ninenines/ct_helper master

`DOC_DEPS` для залежностей, що використовуються лише під час створення 
документації:

[source,make]
DOC_DEPS = edown

`REL_DEPS` для залежностей, що використовуються під час збирання релізу,
або щоб додати додаток до релізу:

[source,make]
REL_DEPS = recon

`SHELL_DEPS` залежності доступні під час виконання команди `make shell`:

[source,make]
SHELL_DEPS = tddreloader

Більш детальна іформація буде задокументована у відповідних главах.

==== Зміна джерела або версії залежностей

За замовчуванням, щоб знайти потрібний проект, Erlang.mk дивиться 
свої індекси пакунків, якщо ви указали лише ім'я. Ось такий випадок:

[source,make]
DEPS = cowboy

Якщо вам потрібна інша версія, ви маєте визначити ще одну змінну. 
Є два способи зробити це, кожен з яких буде у нагоді в певній ситуації.

Якщо ви бажаєте лише змінити commit, все що вам потрібно зробити це 
додати `dep_$(DEP_NAME)_commit`. У випадку з Cowboy, це буде виглядати 
наступним чином:

[source,make]
DEPS = cowboy
dep_cowboy_commit = 2.0.0-pre.2

Erlang.mk буде використовувати індекс пакету для отримання всієї 
інформації окрім номеру commit, котрий буде перевизначено.

Якщо вам треба встановити залежність від власного відгалуження, або
якщо додаток вітсутній в індексах, ви маєте можливість явно вказати 
інформацію про репозиторій. Наприклад:

[source,make]
DEPS = cowboy
dep_cowboy = git https://github.com/essen/cowboy 2.0.0-pre.2

Це призведе до того що Cowboy отримає ваше відгалуження у цьому commit.

==== Методи отримання

Erlang.mk містить декілька методів отримання. Ви маєте можливість 
отримання пакунків з різних систем контроля версій таких як: Git,
Mercurial, SVN, та іншіх. Є методи котрі працюють скрізь, а є методи
 що будуть працювати лише в певному середовищі. 

Методи:

[cols="<,2*^",options="header"]
|===
| Назва          | Формат          | Опис
| git            | git repo commit | Клонує репозиторій Git та перевіряє версію
| git-submodule  | git-submodule   | Ініціалізує та оновлює підмодуль Git
| hg             | hg repo commit  | Клонує репозиторій Mercurial та оновлює до заданної версії
| svn            | svn repo        | Отримує SVN репозиторій
| cp             | cp path/to/repo | Рекусивно копіює локальну теку
| hex            | hex version     | Завантажує задану версію проекту з hex.pm
| fail           | N/A             | Завжди дає збій, зарезервований для внутрішнього використання
| legacy         | N/A             | Збірник застарілих Erlang.mk, зарезервований для внутрішнього використання
|===

Методи `git` та `hg` мають сховище та фіксаціі. Ви можете використовувати
будь-яку гілку або тег з данного репозиторію. 

Наприклад, для отримання Cowboy з тегом 2.0.0-pre.2 з репозиторію Git
треба виконати наступне:

[source,make]
dep_cowboy = git https://github.com/ninenines/cowboy 2.0.0-pre.2

Або отримання Ehsa з тегом 4.0.3 з репозиторію Mercurial:

[source,make]
dep_ehsa = hg https://bitbucket.org/a12n/ehsa 4.0.3

Git має концепцію підмодулей. Erlang.mk може автоматично ініціалізувати
та оновлювати підмодулі для залежностей, якщо вони були заздалегіть 
додані командою `git submodule add`:

[source,make]
dep_cowboy = git-submodule

Метод `svn` має лише значення репозиторію, оскільки URL SVN сховища 
містить інформацію про шлях та фіксації.

Приклад отримання проекту з головної гілки (trunk) репозиторію:

[source,make]
dep_ex1 = svn https://example.com/svn/trunk/project/ex1

Приклад отримання проекту з певною версією фіксації:

[source,make]
dep_ex2 = svn svn://example.com/svn/branches/erlang-proj/ex2@264

Ви маєте можливість копіювати теки з вашого комп'ютера за допомогою
метода `cp`. Треба задати лише шлях для отримання:

[source,make]
dep_cowboy = cp $(HOME)/ninenines/cowboy

Також ви маєте можливість отримання пакунків з 
link:https://hex.pm/[репозиторію Hex]:

[source,make]
dep_cowboy = hex 1.0.3

==== Індивідуальні методи отримання

Якщо жоден з існуючих методів не задовольняє ваших потреб, ви можете
визначити свій власний. Erlang.mk розляне усі змінні типу 
`dep_fetch_$(METHOD)` на предмет наявності доступних методів отримання.
Дозволяється виконання чого завгодно у такій змінній, та в результаті
має створитися папка з назвою '$(DEPS_DIR)/$(call dep_name,$1)'.
Наприклад якщо ваша залежність cowboy папка матиме назву 'deps/cowboy'.

Подивимось приклад того що робить метод Git:

[source,make]
----
define dep_fetch_git
	git clone -q -n -- $(call dep_repo,$1) $(DEPS_DIR)/$(call dep_name,$1); \
	cd $(DEPS_DIR)/$(call dep_name,$1) && git checkout -q $(call dep_commit,$1);
endef
----

Зверніть увагу, цей спеціальний метод витягування, так само як іформація 
про залежності, має бути описано до запуску 'erlang.mk'.

=== Послідовність отримання та збирання залежностей


Порядок отримання та збирання залежностей добре визначений. Erlang.mk
отримає однакові додатки незалежно від команди або опцій що 
використовуються.

Для додатків котрі мають власні залежності Erlang.mk спочатку отримає 
іх. Кожного разу при додавані залежності, рекурсивно будуть виконані 
наступні кроки:

. Отримання всіх залежностей для додатку
. Збирання першої залежності
. Збирання n-ної залежності
. Збирання останньої залежності

Зверніть увагу, перший крок, отримання всіх залежностей, необов'язково
буде виконано в заданому порядку. Таке може статися через те, що немає 
потреби дублювання залежностей в одному додатку задля запобігання 
конфліктів. Пам'ятайте, цей крок потрібен лише для отримання 
залежностей, та в жодному разі не для паралельного збирання різних
додатків.

Щодо конфліктів залежностей різних додатків, то іх не буде. Оскільки 
порядок залежностей добре визначений, буде працювати версія додатку 
з залежності що стоїть раніше.

Мається на увазі, що, якщо проект А залежить від проектів В і С, в 
такому порядку, і що обидва B і C залежать від D, він завжди буде 
версією D з B, тому що ми отримуємо залежності для B до отримання 
залежностей для C.

Так само, якщо проект А залежить від проектів, B, C і D, незалежно 
від порядку, а А, В і С залежать від D, D завжди буде версією з A, 
тому що ми отримуємо всі залежності для А перед отриманням залежностей 
для B та C.

=== Отримання та побудова списку залежностей

Erlang.mk надає можливість рекурсивного отримання всіх залежностей 
без подальшого іх збирання. Для цього використовуйте команду 
`make fetch-deps`. Вона працює за принципами описаними в попередньому 
розділі.

Ви також маєте можливість отримати список залежностей за допомогою 
команди `make list-deps`. Вона рекурсивно отримує всі залежності 
проекту та не збирає їх, так само як це робить `make fetch-deps`, 
після чого виводить список абсолютних шляхів до залежностей.

За замовчуванням команди `fetch-deps` та `list-deps` отримують 
залежності, що описані в `BUILD_DEPS` та `DEPS`. Для отримання 
`TEST_DEPS`, `DOC_DEPS`, `REL_DEPS` та `SHELL_DEPS` є два шляхи:

* Ви можете скористатися командами `make fetch-test-deps`, 
  `make fetch-doc-deps`, `make fetch-rel-deps` та `make fetch-shell-deps`.
  Щоб побудувати список залежностей використовуйте `make list-test-deps`,
  `make list-doc-deps`, `make list-rel-deps` та `make list-shell-deps`.
* Ви можете скористатися командами `make fetch-deps` або `make list-deps`
  позначивши типи залежностей у змінній `DEP_TYPES` Makefile.
  Типами є `test`, `doc`, `rel` та `shell`. Наприклад для отримання 
  списку залежностей `TEST_DEPS` та `DOC_DEPS` командою `make list-deps` 
  DEP_TYPES матиме наступний вигляд `DEP_TYPES='test doc'`.

Зверніть увагу, ви отримаєте список залежностей `TEST_DEPS`, `DOC_DEPS`, 
`REL_DEPS` та `SHELL_DEPS` лише вашого проекту, а не його залежностей.

Незалежно выд методу, `BUILD_DEPS` та `DEPS` завжди будуть отримані.

Команда `make fetch-*` зберігає повний список залежностей у файлах
`$(ERLANG_MK_RECURSIVE_DEPS_LIST)`,
`$(ERLANG_MK_RECURSIVE_TEST_DEPS_LIST)`,
`$(ERLANG_MK_RECURSIVE_DOC_DEPS_LIST)`,
`$(ERLANG_MK_RECURSIVE_REL_DEPS_LIST)` та
`$(ERLANG_MK_RECURSIVE_SHELL_DEPS_LIST)`. 
Для перегляду вмісту цих файлів ви можете скористатися командою 
`make list-*`.

Команди `make list-*` створені для користувача, та якщо ви бажаєте 
отримати список залежностей з Makefile або скрипту, ви маєте 
використовувати зміст саме цих файлів замість використання команд. 
Причина полягає в тому, що результат виконання цих команд може містити 
небажаний контент як-то фактичні вибірки залежностей.

=== Ігнорування небажаних залежностей

Деколи може виникати необхідність повного ігнорування залежностей. 
Наприклад якщо додаток з залежностей вашого проєкту наразі вам 
непотрібен (використовується лише для тестування/документування 
проекту) або йго вже встановлено в вашій системі.

Для ігнорування залежності додайте її до змінної `IGNORE_DEPS`:

[source,make]
IGNORE_DEPS += edown proper

Такий запис призведе до ігнорування залежностей необхідних для збирання, 
тому безпечнішим буде такий запис:

[source,make]
IGNORE_DEPS += edown proper
TEST_DEPS = proper

Додаток PropEr буде отримано під час виконання команд `make tests` 
або `make check`, проте його не буде отримано та зібрано під час
`make` та `make deps`.

=== Тека залежностей

Залежності витягуються у '$(DEPS_DIR)'. За замовчуванням це тека 'deps'.
Ви маєте можливість перевизначити цю теку, але робіть це лише один раз.
Erlang.mk використовує цю змінну для надання залежностям шляху до їх
власних залежностей.

Ви маєте використовувати `?=` замість `=`. Проте якщо ви не збираєтесь
будь коли використовувати свій проект як залежність `=` також 
працюватиме. Щоб уникнути проблем у майбутньому, використовуйте
наступну форму запису:

[source,make]
DEPS_DIR ?= $(CURDIR)/libs

`$(CURDIR)` э важливою частиною, інакше не будуть працювати залежності 
залежностей.

Erlang.mk також експортуватиме змінну `REBAR_DEPS_DIR` для сумісності з
інструментами збирання Rebar, допоки це буде необхідно.

=== Багато додатків в одному репозиторії

Окрім залежностей, що будуть отримані, Erlang.mk дозволяє мати 
залежності локальні для вашого репозиторію. Такий вид компанування 
називають репозиторієм декількох додатків (multi-application 
repositories) або репозиторієм з декількома додатками (repositories 
with multiple applications).

Відмінності від звичайних залежностей:

* Не будуть отримані
* До них не буде автоматично внесено жодних змін (autopatched)
* Їх не буде видалено під час виконання `make distclean`
* Їх не буде автоматично додано до файлу ресурсів проекту

Для правильного заповнення файлу ресурсів програми, ви маєте визначити  
змінну `LOCAL_DEPS` для кожного додатку, так само як для додатків OTP.

Якщо виникає конфлікт між локальною залежністю та залежністю що має 
бути отримана виникатиме помилка під час спроби отримати віддалену 
залежність.

Щоб почати використання локальних залежностей, створіть теку 
'$(APPS_DIR)'. за замовчуванням це тека 'apps/'.

Ви можете скористатися командами `make new-app` або `make new-lib` 
для створення скелету локальних залежностей. Ці команди створять 
потрібні теки для розгортання додатку або бібліотеки.

Наприклад для створення додатку OTP як локальної залежності:

[source,bash]
$ make new-app in=webchat

Або для створення OTP бібліотеки:

[source,bash]
$ make new-lib in=webchat

Шаблони також працюватимуть для залежностей розташованих у корневій 
теці проекту, та ви маєте вказати Erlang.mk в якому саме додатку
треба розгорнути шаблон:

[source,bash]
$ make new t=gen_server n=my_server in=webchat

=== Порожні проекти с залежностями

Є можливість використання порожнього проекту, з одними лише 
локальними залежностями. Для цього створіть теку, покладіть в неї
файл 'erlang.mk', створіть Makefile та створюйте ващі додатки.

Також можливо використання порожнього проекту з залежностями 
з '$(DEPS_DIR)'. Створіть Makefile, та додайте до нього потрібні
залежності. Це, наприклад, дає змогу створити репозиторій для обробки 
та збирання релізів.

=== Autopatch

Erlang.mk автоматично виправляє всі залежності що отримує. 
Це потрібно для забезпечення сумісності з поточною версією Erlang.mk.

Під час отримання залежності виконуються наступні дії:

* Отримання залежності за допомогою обранного методу
* Якщо наявні файли 'configure.ac' або 'configure.in', виконуєтья `autoreconf -Wall -vif -I m4`
* Якщо залежність містить скрипт 'configure', він виконується
* Запуск autopatch у проекті

Autopatch спочатку перевіряє наявність увімкнених патчів для 
конкретного проекту. На цей час є два можливі варіанти: 
`RABBITMQ_CLIENT_PATCH` для залежності `amqp_client` та 
`RABBITMQ_SERVER_PATCH` для залежності `rabbit`. Вони потрібні 
лише при використанні RabbitMQ версій попередніх за 3.6.0 (важається 
що ви використовуєте головну гілку [upstream] а не відгалуження [fork]).

В іншому разі, autopatch виконує різноманітні операції, залежно від
проекту що є залежністю.

* Проекти Rebar автоматично конвертуються для сумісності з Erlang.mk, 
та використання його як інструменту збирання. 

* У Erlang.mk проектах файл 'erlang.mk' перенаправляється 
до Erlang.mk батьківського проекту. Це забезпечує працездатність
функціоналу залежності що використовує застарілу версію Erlang.mk.

* Інші Erlang проекти отримують невеликий Erlang.mk Makefile автоматично. 

* Проекти, в яких відсутня тека src та ті що не містять Makefile 
отримують порожній Makefile для підтримки сумісності.

* Інші проекти, що не містять Makefile лишаються неторканими.

Ви маєте можливість відключення заміни файлу 'erlang.mk'. 
Використовуйте змінну `NO_AUTOPATCH_ERLANG_MK`:

[source,make]
NO_AUTOPATCH_ERLANG_MK = 1

Ви також можете відключити autopatch для окремих проектів указавши
на них у змінній `NO_AUTOPATCH`:

[source,make]
NO_AUTOPATCH = cowboy ranch cowlib

=== Пропуск залежностей

Є можливість пропуску всіх операцій з залежностями. Для цього треба
визначити змінну `SKIP_DEPS`. Така поведінка буде у нагоді якщо
немає можливості для завантаження залежностей, або як своєрідне 
налаштування.

Приклад використання:

[source,bash]
$ make SKIP_DEPS=1

Коли ця змінна визначена:

* Залежності не будуть отримані та зібрані за необхідності
* Тека залежностей '$(DEPS_DIR)' не буде видалена при виконанні `make distclean`

Ця змінна застосовується лише до віддалених залежностей.
